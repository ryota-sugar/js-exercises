### 実行結果

```
console.log(costOfLength(10000));
console.log(costOfLength(100000000));
```

として実行すると、

```
-0.0000012709000000313607
1.6881669999997938e-8
```

という結果になった。また,

```
console.log(costOfLength(100000));
console.log(costOfLength(1000000000));
```

としてNをそれぞれ10倍して実行すると、

```
0.0000012875000000008186
2.4070000000001527e-9
```

という結果になった。

### なぜこのような結果になったのか？

JacaScriptエンジンが搭載しているJIT(Just-In-Time)コンパイラが高度な最適化をしていることにより発生する結果と考えられる。
JITコンパイラは賢すぎるが故に実行結果に影響を与えない無駄な処理を特定して、コードが実行される前に削除する。

今回のコードで言えば、

```
  for (let i = 0; i < N; i++) {
    /* empty */
  }
```

この何をしない処理はJITコンパイラによって実行前に削除され、実際には実行されない。

また、

```
for (let i = 0; i < N; i++) {
    res = str.length;
  }
  const end = performance.now();

  if (res !== 5) {
    throw new Error("something is wrong");
  }
  return end - start;
}
```

この処理ではループは最終的に変数resに5を代入するだけの処理をであることを見抜き、resに5を代入する処理を一回だけ行うコードに置き換えてしまう。

これらのコンパイラの処理によって実行時間が劇的に短くなる。

#### 結果がマイナスになる理由

最適化のタイミングが原因と考えられる。
先に実行される`costOfLengthPlusLoop(N);`が積極的に最適化され超高速になる一方で後から実行される`costOfLoop(N);`のからのループが最適化されずに低速なまま実行されるとマイナスになる現象が発生することがある。

#### Nを増やすと速くなる理由

ループ回数が多いとJITコンパイラがこの処理は重要だと判断し、より強力な最適化をかけるようになる。
このようなウォームアップにより、実行回数が増えるほど最適化の恩恵が大きくなり、計算上の一回あたりの時間が短くなったと考えられる。
