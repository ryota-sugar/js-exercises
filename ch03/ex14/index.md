## 変数をletで定義した場合

### 予想

最後の行の`console.log(i)`で、iが定義されていないため、エラーになる。

### 結果

0
1
2
3
4
5
6
7
8
9
`ReferenceError: i is not defined`となり、最後の行で`i`の未定義エラーになる。

### なぜそのような結果になったのか

letで定義する変数は、同じ変数名であっても異なるスコープ内では宣言することが可能である。
そのため、

```
for (let i = 0; i < 10; i++) {
  (function () {
    let i = 100;
  })();
  console.log(i);
}
```

のように、`i`が2回宣言されていても、1つ目の`i`はfor文のブロックスコープ内であり、2つ目の`i`はfunction関数でのブロックスコープ内であるため、同じ変数名`i`でもエラーにならず宣言できる。

また、関数内の`i`はその関数のブロックスコープ内に限定されるため、forループの`i`に影響を与えない。そのため、`console.log(i);`は0から9までを出力する。

一方最後の行の`console.log(i);`の`i`はグローバル変数の`i`を指している。しかし、全体のコードの中で、グローバル変数`i`を定義していない。そのため、最後の行で`ReferenceError: i is not defined`という未定義のエラーが発生する。

## コード内の全ての let を var に変えた場合

### 結果

```
0
1
2
3
4
5
6
7
8
9
10
```

### 理由

letと異なり、varは関数スコープを持つため、グローバル変数として扱われる。
そのため、for文を抜けた後の`console.log(i);`でも`i`を参照することができ、エラーにならない。
for文を抜ける際に`i++`が実行されているため、最後の行では`10`が出力される。

## 全ての let を消した場合

`package.json`の`"type": "module"`を削除して非strictモードで実行

### 結果

```
100
101
```

### 理由

非strictモードでletやconst,varを使用せずに宣言すると、その変数はグローバル変数として扱われる。

そのため、for文内の`i`はグローバル変数として扱われる。

for文のfuction関数の中で`i=100;`が実行されると、グローバル変数の`i`が100に変更される。よって初めに100が出力される。

`i`が100になると、for文を抜けてしまい、最後に`i++`によって1加算された101が出力される。
